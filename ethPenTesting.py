from web3 import Web3
from http.server import BaseHTTPRequestHandler, HTTPServer
import threading
import requests
import urllib.parse
import json

class WebServer(threading.Thread):
    '''
    This class runs the webserver

    Inputs: 
    Processing: 
    Outputs: http://127.0.0.1:12345
    '''

    def __init__(self):
        # Call the Thread class's init function
        threading.Thread.__init__(self)

    def run(self):
        # This is a method of the Thread class
        # which is called after Thread.start()

        # run the webserver
        while(1):
            with HTTPServer(('localhost', 12345), handler) as server:
                server.serve_forever()

# This class handles requests sent to the web server
class handler(BaseHTTPRequestHandler):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    # stop the webserver from printing out request information
    # to the command line
    def log_message(self, format, *args):
        return
    
    # If the request is a GET request then follow this logic
    def do_GET(self):
        # Hard code valid paths
        valid_paths = ["/",
                       "/index.html",
                       "/favicon.ico",
                       "/w3.css",
                       "/main.css",
                       "/jquery-3.6.1.js"]
        
        # If the requested path is not allowed then return an error
        if(self.path not in valid_paths):
            self.send_response(404)  # Send a 404 Forbidden
            self.send_header('Content-type','application/json')  # Return a json generic error message
            self.end_headers()  # End the headers section
            self.wfile.write('''{"error":"error"}'''.encode("utf-8"))  # write the error message
            return
           
        # The path is valid therefore return data
        # Send a 200 OK to the browser
        self.send_response(200)

        # Return the appropriate Content-type header
        try:
            # Look at the file extension of the requested resource and
            # return the correct content type
            file_type = self.path.split(".")[-1]
            if(file_type == "js"):
                self.send_header('Content-type','text/javascript; charset=UTF-8')
            elif(file_type == "css"):
                self.send_header('Content-type','text/css')
            elif(file_type == "json"):
                self.send_header('Content-type','application/json')
            elif(file_type == "html" or self.path == "/"):
                self.send_header('Content-type','text/html; charset=UTF-8')
            elif(file_type == "ico"):
                self.send_header('Content-type','image/x-icon')
            else:
                self.send_header('Content-type','text/html; charset=UTF-8')
        except:
            pass
        self.end_headers()  # End the headers section

        # If the request is to an allowed javascript or css resource
        # then load that file and return its contents
        # This is manually intensive but ensures the web server isn't
        # returning unintended local files
        if(self.path == "/" or self.path == "/index.html"):
            with open("index.html", "rb") as f:
                self.wfile.write(f.read())
        elif(self.path == "/w3.css"):
            with open("css/w3.css", "rb") as f:
                self.wfile.write(f.read())
        elif(self.path == "/main.css"):
            with open("css/main.css", "rb") as f:
                self.wfile.write(f.read())
        elif(self.path == "/favicon.ico"):
            with open("images/favicon.ico", "rb") as f:
                self.wfile.write(f.read())
        elif(self.path == "/jquery-3.6.1.js"):
            with open("js/jquery-3.6.1.js", "rb") as f:
                self.wfile.write(f.read())
        
    def do_POST(self):
        valid_paths = ["/check_connection",
                       "/gather_info",
                       "/check_apis",
                       "/send_malformed",
                       "/parse_abi",
                       "/call_function",
                       "/deploy_contract",
                       "/contract_storage"]
        
        # If the requested path is not allowed then return an error
        if(self.path not in valid_paths):
            self.send_response(404)  # Send a 404 Forbidden
            self.send_header('Content-type','application/json')  # Return a json generic error message
            self.end_headers()  # End the headers section
            self.wfile.write('''{"error":"error"}'''.encode("utf-8"))  # write the error message
            return
           
        # The path is valid therefore return data
        # Send a 200 OK to the browser
        self.send_response(200)

        # Return the appropriate Content-type header
        try:
            # Look at the file extension of the requested resource and
            # return the correct content type
            file_type = self.path.split(".")[-1]
            if(file_type == "js"):
                self.send_header('Content-type','text/javascript; charset=UTF-8')
            elif(file_type == "css"):
                self.send_header('Content-type','text/css')
            elif(file_type == "json"):
                self.send_header('Content-type','application/json')
            elif(file_type == "html" or self.path == "/"):
                self.send_header('Content-type','text/html; charset=UTF-8')
            elif(file_type == "ico"):
                self.send_header('Content-type','image/x-icon')
            else:
                self.send_header('Content-type','text/html; charset=UTF-8')
        except:
            pass
        self.end_headers()  # End the headers section

        # If the request is to an allowed javascript or css resource
        # then load that file and return its contents
        # This is manually intensive but ensures the web server isn't
        # returning unintended local files
        if(self.path == "/check_connection"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).checkConnection()
            self.wfile.write(str(response).encode("utf-8"))
        elif(self.path == "/gather_info"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).gatherNodeInfo()
            self.wfile.write(str(response).encode("utf-8"))
        elif(self.path == "/check_apis"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).checkAPI()
            self.wfile.write(str(response).encode("utf-8"))
        elif(self.path == "/send_malformed"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).sendMalformed()
            self.wfile.write(str(response).encode("utf-8"))
        elif(self.path == "/parse_abi"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            node_info["contract_abi"] = urllib.parse.unquote_plus(node_info["contract_abi"])  # url decode the abi parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).parseABI(node_info["contract_abi"])
            self.wfile.write(str(response).encode("utf-8"))
        elif(self.path == "/call_function"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            node_info["contract_abi"] = urllib.parse.unquote_plus(node_info["contract_abi"])  # url decode the abi parameter
            node_info["function_args"] = urllib.parse.unquote_plus(node_info["function_args"])  # url decode the function args parameter
            node_info["function_name"] = urllib.parse.unquote_plus(node_info["function_name"])  # url decode the function args parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).callFunction(node_info)
            self.wfile.write(str(response).encode("utf-8"))
        elif(self.path == "/deploy_contract"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            node_info["contract_abi"] = urllib.parse.unquote_plus(node_info["contract_abi"])  # url decode the abi parameter
            node_info["contract_bytecode"] = urllib.parse.unquote_plus(node_info["contract_bytecode"])  # url decode the bytecode parameter
            node_info["contract_args"] = urllib.parse.unquote_plus(node_info["contract_args"])  # url decode the function args parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).deployContract(node_info)
            self.wfile.write(str(response).encode("utf-8"))
        elif(self.path == "/contract_storage"):
            node_info = self.handleRequest(self.rfile.read(int(self.headers.get('Content-Length'))))
            node_info["node_path"] = urllib.parse.unquote_plus(node_info["node_path"])  # url decode the path parameter
            response = ethPenTesting(node_info["node_ip"], node_info["node_path"], node_info["node_port"],
                                     node_info["node_protocol"], node_info["node_jsonrpc"], node_info["node_proxy"]).getContractStorage(node_info["public_address"], node_info["contract_address"], node_info["storage_start"], node_info["storage_end"])
            self.wfile.write(str(response).encode("utf-8"))

    def handleRequest(self, request_body):
        '''
        INPUTS: POST form data from rfile.read()
        PROCESSING: parse the form body
        OUTPUTS: return a dict with the form body fields
        '''
        request = {}  # create an empty dict that we will return
        
        # request_body = b'node_ip=127.0.0.1&node_path=&node_port=&node_protocol=&node_jsonrpc=&node_proxy=false'
        request_list = request_body.decode("utf-8").split("&")
        # request_list = ['node_ip=127.0.0.1', 'node_path=', 'node_port=', 'node_protocol=', 'node_jsonrpc=', 'node_proxy=false']
        for field in request_list:
            key, value = field.split("=")
            request[key] = value
        return request

class ethPenTesting():
    '''
    Inputs: Node information (ip, port, etc...)
    Processing: Interact with the ethereum node to perform various tasks
    Outputs: 
    '''
    def __init__(self, node_ip, url_path, node_port, node_protocol, json_rpc_version, node_proxy):
        pass
        # Save the IP, port, etc... to self because they'll be used in every method
        self.node_ip_domain = node_ip
        self.node_port = node_port
        self.node_protocol = node_protocol
        self.node_jsonrpc = json_rpc_version
        self.node_proxy = node_proxy
        if(self.node_proxy == "true"):
            self.proxies = {"http":"http://127.0.0.1:8080", "https":"https://127.0.0.1:8080"}
        else:
            self.proxies = {}

        self.url = self.node_protocol + "://" + self.node_ip_domain + ":" + self.node_port + url_path
        
    def callRPC(self, method, params, custom_json=0):
        '''
        This is the generic method that makes RPC calls
        
        Inputs: jsonrpc method, params, or optionally custom_json which allows you to send malformed stuff to the node
        Processing: Send the request to the node
        Outputs: Return the response, or return "error"
        '''
        
        if(custom_json == 0):
            rpc = {"jsonrpc":self.node_jsonrpc, "method":method, "params":params, "id":1}
            response = requests.post(self.url, json=rpc, proxies=self.proxies)
            json_response = response.json()
            # If the server returns an error, just print 'error'
            try:
                if(json_response["error"]):
                    return "error"
            except:
                pass
            return json_response
        else:
            rpc = custom_json
            try:
                response = requests.post(self.url, json=rpc, proxies=self.proxies)
                json_response = response.json()
                return json_response
            except:
                return "error"
    
    def checkConnection(self):
        # Make a simple rpc call to see if the configuration info is correct
        web3_clientVersion_json = self.callRPC("web3_clientVersion", [])
        if(web3_clientVersion_json == "error"):
            return "error"
        else:
            return web3_clientVersion_json["result"]

    def gatherNodeInfo(self):
        '''
        INPUTS: node information like IP, port, etc...
        PROCESSING: Send multiple common JSON RPC requests to the node to gather info
        OUTPUTS: Return a string with all the responses for the web app
        '''
        response = ""
        
        web3_clientVersion_json = self.callRPC("web3_clientVersion", [])
        if(web3_clientVersion_json == "error"):
            response += "web3_clientVersion: ERROR\n"
        else:
            response += "web3_clientVersion: " + str(web3_clientVersion_json["result"]) + "\n"

        net_version_json = self.callRPC("net_version", [])
        if(net_version_json == "error"):
            response += "net_version: ERROR\n"
        else:
            response += "net_version: " + str(net_version_json["result"]) + "\n"

        net_listening_json = self.callRPC("net_listening", [])
        if(net_listening_json == "error"):
            response += "net_listening: ERROR\n"
        else:
            response += "net_listening: " + str(net_listening_json["result"]) + "\n"

        net_peerCount_json = self.callRPC("net_peerCount", [])
        if(net_peerCount_json == "error"):
            response += "net_peerCount: ERROR\n"
        else:
            response += "net_peerCount: " + str(net_peerCount_json["result"]) + "\n"

        eth_protocolVersion_json = self.callRPC("eth_protocolVersion", [])
        if(eth_protocolVersion_json == "error"):
            response += "eth_protocolVersion: ERROR\n"
        else:
            response += "eth_protocolVersion: " + str(eth_protocolVersion_json["result"]) + "\n"

        eth_syncing_json = self.callRPC("eth_syncing", [])
        if(eth_syncing_json == "error"):
            response += "eth_syncing: ERROR\n"
        else:
            response += "eth_syncing: " + str(eth_syncing_json["result"]) + "\n"

        eth_coinbase_json = self.callRPC("eth_coinbase", [])
        if(eth_coinbase_json == "error"):
            response += "eth_coinbase: ERROR\n"
        else:
            response += "eth_coinbase: " + str(eth_coinbase_json["result"]) + "\n"

        eth_gasPrice_json = self.callRPC("eth_gasPrice", [])
        if(eth_gasPrice_json == "error"):
            response += "eth_gasPrice: ERROR\n"
        else:
            response += "eth_gasPrice: " + str(eth_gasPrice_json["result"]) + "\n"

        eth_blockNumber_json = self.callRPC("eth_blockNumber", [])
        if(eth_blockNumber_json == "error"):
            response += "eth_blockNumber: ERROR\n"
        else:
            response += "eth_blockNumber: " + str(eth_blockNumber_json["result"]) + "\n"

        eth_accounts_json = self.callRPC("eth_accounts", [])
        if(eth_accounts_json == "error"):
            response += "eth_accounts: ERROR\n"
        else:
            response += "eth_accounts: " + str(eth_accounts_json["result"]) + "\n"

        return response

    def checkAPI(self):
        '''
        INPUTS: node information like IP, port, etc...
        PROCESSING: Send multiple requests to interesting endpoints. See if they have the
                    admin endpoints enabled by mistake for example.
        OUTPUTS: Return a string with all the responses for the web app
        '''
        response = ""
        
        response += "DEPRECATED CALLS:\n"
        
        shh_version_json = self.callRPC("shh_version", [])
        if(shh_version_json == "error"):
            response += "shh_version: ERROR\n"
        else:
            response += "shh_version: " + str(shh_version_json["result"]) + "\n"

        response += "\nGETH CHECKS:\n"

        admin_nodeInfo_json = self.callRPC("admin_nodeInfo", [])
        if(admin_nodeInfo_json == "error"):
            response += "admin_nodeInfo: ERROR\n"
        else:
            response += "admin_nodeInfo: " + str(admin_nodeInfo_json["result"]) + "\n"

        admin_datadir_json = self.callRPC("admin_datadir", [])
        if(admin_datadir_json == "error"):
            response += "admin_datadir: ERROR\n"
        else:
            response += "admin_datadir: " + str(admin_datadir_json["result"]) + "\n"

        clique_proposals_json = self.callRPC("clique_proposals", [])
        if(clique_proposals_json == "error"):
            response += "clique_proposals: ERROR\n"
        else:
            response += "clique_proposals: " + str(clique_proposals_json["result"]) + "\n"

        debug_memStats_json = self.callRPC("debug_memStats", [])
        if(debug_memStats_json == "error"):
            response += "debug_memStats: ERROR\n"
        else:
            response += "debug_memStats: " + str(debug_memStats_json["result"]) + "\n"

        les_serverInfo_json = self.callRPC("les_serverInfo", [])
        if(les_serverInfo_json == "error"):
            response += "les_serverInfo: ERROR\n"
        else:
            response += "les_serverInfo: " + str(les_serverInfo_json["result"]) + "\n"

        miner_getHashrate_json = self.callRPC("miner_getHashrate", [])
        if(miner_getHashrate_json == "error"):
            response += "miner_getHashrate: ERROR\n"
        else:
            response += "miner_getHashrate: " + str(miner_getHashrate_json["result"]) + "\n"

        personal_listAccounts_json = self.callRPC("personal_listAccounts", [])
        if(personal_listAccounts_json == "error"):
            response += "personal_listAccounts: ERROR\n"
        else:
            response += "personal_listAccounts: " + str(personal_listAccounts_json["result"]) + "\n"

        personal_listWallets_json = self.callRPC("personal_listWallets", [])
        if(personal_listWallets_json == "error"):
            response += "personal_listWallets: ERROR\n"
        else:
            response += "personal_listWallets: " + str(personal_listWallets_json["result"]) + "\n"

        txpool_status_json = self.callRPC("txpool_status", [])
        if(txpool_status_json == "error"):
            response += "txpool_status: ERROR\n"
        else:
            response += "txpool_status: " + str(txpool_status_json["result"]) + "\n"

        return response

    def sendMalformed(self):
        '''
        INPUTS: node information like IP, port, etc...
        PROCESSING: Send a few malformed requests in order to hopefully induce a stack trace
                    which should reveal what kind of node they're running
        OUTPUTS: Return a string with all the responses for the web app
        '''
        response = ""

        # Empty method/params
        empty_method_json = self.callRPC("", [],
                                         {"jsonrpc":self.node_jsonrpc,
                                          "method":"",
                                          "params":[],
                                          "id":1})
        response += "empty_method: " + str(empty_method_json) + "\n\n"

        # Add single quote after invalid method
        single_quote_json = self.callRPC("", [],
                                         {"jsonrpc":self.node_jsonrpc,
                                          "method":"test'",
                                          "params":[],
                                          "id":1})
        response += "single quote after invalid method: " + str(single_quote_json) + "\n\n"

        # Don't provide params on method that requires them
        empty_params_json = self.callRPC("", [],
                                         {"jsonrpc":self.node_jsonrpc,
                                          "method":"eth_getBalance",
                                          "params":[],
                                          "id":1})
        response += "empty params on method that requires them: " + str(empty_params_json) + "\n"

        return response

    def parseABI(self, abi):
        '''
        INPUTS: abi
        PROCESSING: parse the abi
        OUTPUTS: dynamic html with the abi fields
        '''
        abi = json.loads(abi)

        constructor = ""
        functions = ""
        events = ""
        output_html = ""

        # look for contructor inputs first
        for entry in abi:
            for key in entry:
                if(key == "type"):
                    if(entry[key] == "constructor"):  # find the constructor types
                        try:
                            output_html += '''<p class="function_group">'''
                            output_html += '''<label class="w3-text-aqua function_output"><b>Constructor</b></label><br>'''
                            for i in entry["inputs"]:  # for each constructor input
                                output_html += '''<label class="w3-text-aqua function_label"><b>''' + str(i["name"]) + '''</b></label>'''
                                output_html += '''<input class="w3-input w3-border w3-light-grey function_input constructor_input" type="text" placeholder="''' + str(i["type"]) + '''">'''
                            output_html += '''</p><hr  width="31%">'''
                        except Exception as e:
                            print(e)
        # look for functions and events
        for entry in abi:
            for key in entry:
                if(key == "type"):
                    if(entry[key] == "function"):
                        try:
                            # Function Group
                            output_html += '''<p class="function_group">'''
                                # Function button
                            output_html += '''<button id="contract_function_button_''' + str(entry["name"]) + '''" class="w3-btn w3-blue-grey function_button">''' + str(entry["name"]) + '''</button>'''
                                # Function output
                            output_html += '''<label class="w3-text-aqua contract_function_''' + str(entry["name"]) + '''_output"><b></b></label><br>'''
                                    # Function arguments input fields
                            args = {}
                            for i in entry["inputs"]:
                                output_html += '''<label class="w3-text-aqua function_label"><b>''' + str(i["name"]) + '''</b></label>'''
                                output_html += '''<input class="w3-input w3-border w3-light-grey function_input function_parameter_''' + str(entry["name"]) + '''" name="''' + str(i["name"]) + '''" type="text" placeholder="''' + str(i["type"]) + '''">'''
                            output_html += '''</p><hr width="31%">'''
                            # End of Function Group
                            # Add jQuery stuff for the above function group
                                # When the function button is clicked
                            output_html += '''<script>$("#contract_function_button_''' + str(entry["name"]) + '''").click(function(){'''
                                    # Create a dictionary which will hold the function name and its arguments
                            output_html += '''var function_args = {};'''
                                    # For each of the function's arguments
                            output_html += '''$(".function_parameter_''' + str(entry["name"]) + '''").each(function(index, obj){'''
                                        # Get the argument's name and value from the html
                            output_html += '''function_args[obj.name] = obj.value;'''
                            output_html += '''});'''
                                    # Add the function name to the dictionary
                            #output_html += '''function_args["function_name"] = "''' + str(entry["name"]) + '''";'''
                                    # Normal jQuery to get value of proxy checkbox
                            output_html += '''var checked = "false"; if($("#node_proxy").is(":checked")){checked = "true";}'''
                                    # Normal jQuery for the fields sent with all post requests
                            output_html += '''var request_normal_fields = {node_ip: $("#node_ip").val(), node_path: $("#node_path").val(), node_port: $("#node_port").val(), '''
                            output_html += '''node_protocol: $("#node_protocol").val(), node_jsonrpc: $("#node_jsonrpc").val(), node_proxy: checked, contract_abi: $("#contract_abi").val(), '''
                            output_html += '''contract_address: $("#contract_address").val(), function_name: "''' + str(entry["name"]) + '''", '''
                            output_html += '''function_args: JSON.stringify(function_args), public_address: $("#public_address").val(), private_key: $("#private_key").val(),'''
                            output_html += '''ether_amount: $("#ether_amount").val(), gas_amount: $("#gas_amount").val(), gas_price_gwei: $("#gas_price_gwei").val(),'''
                            output_html += '''};'''
                                    # Combine the object with node information with our object above which contains the function's arguments
                            ##output_html += '''var request_object = Object.assign(function_args, request_normal_fields);'''
                                    # Send a post request to /function with all of the required fields including the function name and arguments
                                    # Add the response to the DOM
                            output_html += '''$.post("/call_function", request_normal_fields, function(data, status){$(".contract_function_''' + str(entry["name"]) + '''_output").html(data);'''
                            output_html += '''});'''
                            output_html += '''});'''
                            output_html += '''</script>'''
                        except Exception as e:
                            print(e)
                    elif(entry[key] == "event"):
                        events += entry["name"] + "\n"

        return output_html

    def convertArgTypes(self, contract_args, abi, function_name):
        '''
        INPUTS: dictionary with arguments for a contract function
        PROCESSING: using the contract abi, convert the arguments into their appropriate data type
        OUTPUTS: return dictionary with arguments for contract function but with the correct data type
        '''
        for arg in contract_args:
            variable_name = arg  # contract argument name
            variable_value = contract_args[arg]  # contract argument value
            for entry in abi:  # get the arg type according to the abi
                for key in entry:
                    if(key == "type"):
                        if(entry[key] == "constructor" and function_name == "constructor"):
                            for input_arg in entry["inputs"]:
                                if(input_arg["name"] == variable_name):
                                    arg_type = input_arg["type"]
                                    stateMutability = entry["stateMutability"]
                        elif(entry[key] == "function" and entry["name"] == function_name):
                            for input_arg in entry["inputs"]:
                                if(input_arg["name"] == variable_name):
                                    arg_type = input_arg["type"]
                                    stateMutability = entry["stateMutability"]
            try:
                # Depending on the argument type, convert the variable
                if("int" in arg_type):
                    contract_args[arg] = int(contract_args[arg])
                elif("bool" in arg_type):
                    if(contract_args[arg].lower() == "true"):
                        contract_args[arg] = True
                    elif(contract_args[arg].lower() == "false"):
                        contract_args[arg] = False
                elif("bytes" in arg_type and "[]" in arg_type):
                    # if it's a byte array
                    # test,0x12aa3f
                    contract_args[arg] = contract_args[arg].split(",")
                    for i in range(0, len(contract_args[arg])):
                        if(contract_args[arg][i][0:2] == "0x"):
                            contract_args[arg][i] = bytes.fromhex(contract_args[arg][i][2:])
                        else:
                            contract_args[arg][i] = contract_args[arg][i].encode()
                elif("bytes" in arg_type):
                    if(contract_args[arg][0:2] == "0x"):
                        contract_args[arg] = bytes.fromhex(contract_args[arg][2:])
                    else:
                        contract_args[arg] = contract_args[arg].encode()
                return contract_args, stateMutability
            except Exception as e:
                print(e)
                return contract_args, "nonpayable"
        if(contract_args == {}):
            for entry in abi:  # get the arg type according to the abi
                for key in entry:
                    if(key == "type"):
                        if(entry[key] == "constructor" and function_name == "constructor"):
                            return None, entry["stateMutability"]
                        elif(entry[key] == "function" and entry["name"] == function_name):
                            return None, entry["stateMutability"]

    def deployContract(self, node_info):
        '''
        INPUTS: node information like IP, port, etc... and your public address/private key and the contract's abi/bytecode
        PROCESSING: send a transaction to deploy the contract
        OUTPUTS: Return the deployed address
        '''
        #print(node_info["contract_abi"], node_info["contract_bytecode"])
        #print(node_info)

        # If the proxy is set then proxy through burp
        if(self.node_proxy == "false"):
            web3 = Web3(Web3.HTTPProvider(self.url))
        else:
            web3 = Web3(Web3.HTTPProvider(self.url, request_kwargs={"proxies":self.proxies}))

        # Set your public address
        web3.eth.defaultAccount = node_info["public_address"]
        # Create a contract object with the ABI and bytecode
        self.contract = web3.eth.contract(abi=node_info["contract_abi"], bytecode=node_info["contract_bytecode"])
        # Get the constructor arguments
        contract_args = json.loads(node_info["contract_args"])
        abi = json.loads(node_info["contract_abi"])
        contract_args, stateMutability = self.convertArgTypes(contract_args, abi, "constructor")  # convert the args to the correct data type
        
        # set values we'll need for the transaction
        chainId = web3.eth.chain_id
        nonce = web3.eth.getTransactionCount(node_info["public_address"])

        value = web3.toWei(float(node_info["ether_amount"]), "ether")
        gas = int(node_info["gas_amount"])
        gasPrice = int(node_info["gas_price_gwei"])

        # build the transaction
        if(stateMutability == "payable"):
            tx = {"nonce":nonce, "from": node_info["public_address"], "gas": gas, "gasPrice":web3.toWei(gasPrice, "gwei"), "chainId":chainId, "value":value}
        else:
            tx = {"nonce":nonce, "from": node_info["public_address"], "gas": gas, "gasPrice":web3.toWei(gasPrice, "gwei"), "chainId":chainId}
        # **contract_args, Use this link for why this works https://www.geeksforgeeks.org/args-kwargs-python/
        # Basically pass in our dictionary with our arguments to the constructor
        if(contract_args == None):
            contract_tx = self.contract.constructor().buildTransaction(tx)
        else:
            contract_tx = self.contract.constructor(**contract_args).buildTransaction(tx)

        # sign the transaction with the user's private key
        contract_tx_signed = web3.eth.account.signTransaction(contract_tx, private_key=node_info["private_key"])

        # send the transaction and wait for it to be added to a block
        tx_hash = web3.eth.sendRawTransaction(contract_tx_signed.rawTransaction)
        tx_receipt = web3.eth.waitForTransactionReceipt(tx_hash)

        return str(tx_receipt["contractAddress"])       

    def callFunction(self, node_info):
        '''
        INPUTS: node information like IP, port, etc... and your public address/private key and the contract's abi/bytecode
        PROCESSING: send a transaction to called contract's function
        OUTPUTS: Return the result
        '''

        # If the proxy is set then proxy through burp
        if(self.node_proxy == "false"):
            web3 = Web3(Web3.HTTPProvider(self.url))
        else:
            web3 = Web3(Web3.HTTPProvider(self.url, request_kwargs={"proxies":self.proxies}))

        # Set your public address
        web3.eth.defaultAccount = node_info["public_address"]
        
        # Create a contract object with the ABI and bytecode
        self.contract = web3.eth.contract(abi=node_info["contract_abi"], address=node_info["contract_address"])
        abi = json.loads(node_info["contract_abi"])
        
        # Get the function name and arguments
        function_name = node_info["function_name"]
        function_args = json.loads(node_info["function_args"])
        function_args, stateMutability = self.convertArgTypes(function_args, abi, function_name)  # convert the args to the correct data type

        # set values we'll need for the transaction
        chainId = web3.eth.chain_id
        nonce = web3.eth.getTransactionCount(node_info["public_address"])

        value = web3.toWei(float(node_info["ether_amount"]), "ether")
        gas = int(node_info["gas_amount"])
        gasPrice = int(node_info["gas_price_gwei"])

        # build the transaction
        if(stateMutability == "view" or stateMutability == "pure"):
            if(function_args):
                return self.contract.functions[function_name](**function_args).call()
            else:
                return self.contract.functions[function_name]().call()
        elif(stateMutability == "payable"):
            tx = {"nonce":nonce, "from": node_info["public_address"], "gas": gas, "gasPrice":web3.toWei(gasPrice, "gwei"), "chainId":chainId, "value":value}
        else:
            tx = {"nonce":nonce, "from": node_info["public_address"], "gas": gas, "gasPrice":web3.toWei(gasPrice, "gwei"), "chainId":chainId}
        #tx = {"nonce":nonce, "from": node_info["public_address"], "gas": gas, "gasPrice":web3.toWei(gasPrice, "gwei"), "chainId":chainId, "value":value}
        #tx = {"nonce":nonce, "from": node_info["public_address"], "gas": gas, "gasPrice":web3.toWei(gasPrice, "gwei"), "chainId":chainId}
        #print(dir(self.contract.functions[function_name]))
        #print(self.contract.functions[function_name].contract_abi)
        #print(dir(self.contract.functions["delegate"]))
        # **contract_args, Use this link for why this works https://www.geeksforgeeks.org/args-kwargs-python/
        # Basically pass in our dictionary with our arguments to the constructor
        if(function_args == None):
            function_tx = self.contract.functions[function_name]().buildTransaction(tx)
        else:
            function_tx = self.contract.functions[function_name](**function_args).buildTransaction(tx)

        # sign the transaction with the user's private key
        function_tx_signed = web3.eth.account.signTransaction(function_tx, private_key=node_info["private_key"])

        # send the transaction and wait for it to be added to a block
        tx_hash = web3.eth.sendRawTransaction(function_tx_signed.rawTransaction)
        tx_receipt = web3.eth.waitForTransactionReceipt(tx_hash)

        return str(tx_receipt)   

    def getContractStorage(self, your_public_address, contract_address, storage_slot_start, storage_slot_end):
        '''
        INPUTS: node information like IP, port, etc... and your public address and the contract's address
                Also the beginning storage slot and ending storage slot
        PROCESSING: Send multiple requests to get the contract's storage
        OUTPUTS: Return a string with all the responses for the web app
        '''

        storage = ""
        
        if(self.node_proxy == "false"):
            web3 = Web3(Web3.HTTPProvider(self.url))
        else:
            web3 = Web3(Web3.HTTPProvider(self.url, request_kwargs={"proxies":self.proxies}))

        web3.eth.defaultAccount = your_public_address

        for i in range(int(storage_slot_start), int(storage_slot_end)):
            storage_value = web3.eth.getStorageAt(contract_address, i)
##            <p>
##            <label class="w3-text-aqua contract_storage_label"><b>Slot 1: </b></label>
##            <label class="w3-text-aqua contract_storage_label"><b>0x00121234ads</b></label>
##            <label class="w3-text-aqua contract_storage_label"><b>abcde</b></label>
##            </p>
            storage += "<p>"
            storage += '''<label class="w3-text-aqua contract_storage_label"><b>Slot ''' + str(i) + ''': </b></label>'''
            storage += '''<label class="w3-text-aqua contract_storage_label"><b>''' + web3.toHex(storage_value) + '''</b></label>'''
            try:
                storage += '''<label class="w3-text-aqua contract_storage_label"><b>''' + storage_value.decode("latin1") + '''</b></label>'''
            except Exception as e:
                pass
            storage += "</p>"

        return storage


webserver_thread = WebServer()
webserver_thread.start()
